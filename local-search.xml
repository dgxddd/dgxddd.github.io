<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/10/29/%E5%AF%86%E7%A0%81/sm3/"/>
    <url>/2025/10/29/%E5%AF%86%E7%A0%81/sm3/</url>
    
    <content type="html"><![CDATA[<h1 id="国密SM3算法"><a href="#国密SM3算法" class="headerlink" title="国密SM3算法"></a><strong>国密SM3算法</strong></h1><h2 id="一、概述及其特点"><a href="#一、概述及其特点" class="headerlink" title="一、概述及其特点"></a>一、<strong>概述及其特点</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>​       SM3密码杂凑算法是中国国家密码管理局2010年公布的中国商用密码杂凑算法标准。具体算法标准原始文本参见参考文献[1]。该算法于2012年发布为密码行业标准(<a href="https://zhida.zhihu.com/search?content_id=116951744&content_type=Article&match_order=1&q=GM/T+0004-2012&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjE4MzA3OTUsInEiOiJHTS9UIDAwMDQtMjAxMiIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjExNjk1MTc0NCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.FshGANoIJ-jTtsSBN7B2UjeRKLaHIJCG2fUIMiFa528&zhida_source=entity">GM&#x2F;T 0004-2012</a>)，2016年发布为国家密码杂凑算法标准(<a href="https://zhida.zhihu.com/search?content_id=116951744&content_type=Article&match_order=1&q=GB/T+32905-2016&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjE4MzA3OTUsInEiOiJHQi9UIDMyOTA1LTIwMTYiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMTY5NTE3NDQsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.f7-uwJHh03jvb_ZQk-tS8Nz2NfJLY4Lr0wkzLQfuKUI&zhida_source=entity">GB&#x2F;T 32905-2016</a>)。</p><p>​      SM3适用于商用密码应用中的数字签名和验证，是在SHA-256基础上改进实现的一种算法，其安全性和SHA-256相当。SM3和MD5的迭代过程类似，也采用<a href="https://zhida.zhihu.com/search?content_id=116951744&content_type=Article&match_order=1&q=Merkle-Damgard%E7%BB%93%E6%9E%84&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjE4MzA3OTUsInEiOiJNZXJrbGUtRGFtZ2FyZOe7k-aehCIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjExNjk1MTc0NCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.o1N5_yHjLtI7fWzWLIBIjNvF5xnIdMavEQ6UxK3e1Uo&zhida_source=entity">Merkle-Damgard结构</a>。消息分组长度为512位，摘要值长度为256位。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>固定长度输出：SM3对任意长度的输入消息，均生成固定长度为256位的杂凑值，具备抗碰撞、抗第二原像等安全特性，确保数据完整性与唯一性。</li><li>结构与安全性：采用成熟的Merkle-Damgård结构，具备强雪崩效应，输入微小变动会导致输出显著不同，有效抵御密码分析攻击。</li><li>高效性：算法设计兼顾软硬件实现效率，运算过程基于位操作与逻辑函数，适用于资源受限的物联网设备、嵌入式系统及高性能服务器。</li><li>广泛用途：作为基础密码组件，SM3常用于数字签名、消息认证码生成、随机数生成及数据完整性校验，是实现身份鉴别与防篡改的核心工具。</li></ul><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a><strong>组成部分</strong></h3><ol><li><strong>数据填充</strong><br>将任意长度的消息填充为512位的整数倍，并在末尾附加原始长度。</li><li><strong>消息扩展</strong><br>将每个512位的分组扩展生成132个字，用于后续计算，以消除数据规律。</li><li><strong>压缩函数（核心）</strong><br>将扩展后的消息与中间结果进行64轮混合运算，充分打乱数据，生成新的哈希值。</li><li><strong>迭代结构</strong><br>按顺序将每个填充后的分组送入压缩函数进行处理，最后一个输出的结果就是最终的SM3哈希值。</li></ol><h3 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h3><ol><li><strong>压缩函数</strong><ul><li>这是SM3的<strong>绝对核心</strong>，是一个单向的“数据搅拌器”。</li><li>它将一个512位的消息分组和当前的256位中间状态值进行混合，通过64轮复杂的数学运算（包括位运算、模加等），输出一个新的256位中间状态值。</li><li>它确保了数据的任何微小变化都会扩散到整个输出中。</li></ul></li><li><strong>迭代结构</strong><ul><li>它定义了如何用“压缩函数”处理长消息，即**“分块处理，链式连接”**。</li><li>算法将填充后的消息切成多个512位的块。第一个块与一个固定的<strong>初始值</strong>一起压缩，产生的输出作为下一个块的输入，如此反复。最后一个块的输出就是最终的哈希值。</li></ul></li><li><strong>消息扩展</strong><ul><li>这是压缩函数的“燃料准备”阶段。</li><li>它将一个512位的输入块扩展成132个更小的数据单元，为64轮运算提供“弹药”。这个过程本身也增加了数据的随机性和依赖性，进一步增强了安全性。</li></ul></li></ol><h2 id="二、大致流程"><a href="#二、大致流程" class="headerlink" title="二、大致流程"></a><strong>二、大致流程</strong></h2><h3 id="第一步：消息填充"><a href="#第一步：消息填充" class="headerlink" title="第一步：消息填充"></a><strong>第一步：消息填充</strong></h3><ol><li><strong>添加比特’1’</strong>：在原始消息的末尾首先添加一个二进制的<code>1</code>。</li><li><strong>添加k个比特’0’</strong>：<code>k</code>是满足以下等式的最小非负整数：<br><code>(原始消息长度(位) + 1 + k) ≡ 448 (mod 512)</code><br>这确保了填充后（还未加长度信息）的消息长度恰好比512位的整数倍少64位。</li><li><strong>附加长度信息</strong>：在末尾添加一个64位的字段，用来表示<strong>原始消息的二进制位长度</strong></li></ol><h3 id="第二步：消息扩展"><a href="#第二步：消息扩展" class="headerlink" title="第二步：消息扩展"></a><strong>第二步：消息扩展</strong></h3><p>SM3的迭代压缩步骤没有直接使用数据分组进行运算，而是使用这个步骤产生的132个消息字。（一个消息字的长度为32位&#x2F;4个字节&#x2F;8个16j进制数字）概括来说，先将一个512位数据分组划分为16个消息字，并且作为生成的132个消息字的前16个。再用这16个消息字递推生成剩余的116个消息字。</p><p>在最终得到的132个消息字中，前68个消息字构成数列 {W j {W_j}Wj}，后64个消息字构成数列 {W j ‘ {W_j^&#96;}Wj‘}，其中下标j从0开始计数。</p><h3 id="第三步：迭代压缩"><a href="#第三步：迭代压缩" class="headerlink" title="第三步：迭代压缩"></a><strong>第三步：迭代压缩</strong></h3><p><img src="https://jxdgx.oss-cn-beijing.aliyuncs.com/image-20251028225529828.png" alt="image-20251028225529828"></p><p>最后，再将计算完成的A、B、C、D、E、F、G、H和原来的A、B、C、D、E、F、G、H分别进行异或，就是压缩函数的输出。这个输出再作为下一次调用压缩函数时的初值。依次类推，直到用完最后一组132个消息字为止。</p><h3 id="第四步：输出结果"><a href="#第四步：输出结果" class="headerlink" title="第四步：输出结果"></a><strong>第四步：输出结果</strong></h3><p>将得到的A、B、C、D、E、F、G、H八个变量拼接输出，就是SM3算法的输出。</p><h2 id="三-SM3加密"><a href="#三-SM3加密" class="headerlink" title="三. SM3加密"></a>三. <strong>SM3加密</strong></h2><p>SM3是中国国家密码管理局发布的密码杂凑算法标准，用于生成256位（32字节）的哈希值。代码实现了SM3算法的所有核心组件：消息填充、消息扩展、压缩函数和迭代哈希计算。</p><h3 id="1-初始向量-IV"><a href="#1-初始向量-IV" class="headerlink" title="1. 初始向量 IV"></a>1. 初始向量 <code>IV</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">IV = [<br>    <span class="hljs-number">0x7380166F</span>, <span class="hljs-number">0x4914B2B9</span>, <span class="hljs-number">0x172442D7</span>, <span class="hljs-number">0xDA8A0600</span>,<br>    <span class="hljs-number">0xA96F30BC</span>, <span class="hljs-number">0x163138AA</span>, <span class="hljs-number">0xE38DEE4D</span>, <span class="hljs-number">0xB0FB0E4E</span><br>]<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：SM3算法的初始哈希值，包含8个32位字，作为哈希计算的起点。</p><h3 id="2-布尔函数-FF-X-Y-Z-j"><a href="#2-布尔函数-FF-X-Y-Z-j" class="headerlink" title="2. 布尔函数 FF(X, Y, Z, j)"></a>2. 布尔函数 <code>FF(X, Y, Z, j)</code></h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp">def FF(<span class="hljs-keyword">X</span>, <span class="hljs-keyword">Y</span>, <span class="hljs-keyword">Z</span>, j):<br>    if j &lt; <span class="hljs-number">16</span>:<br>        return <span class="hljs-keyword">X</span> ^ <span class="hljs-keyword">Y</span> ^ <span class="hljs-keyword">Z</span>  # 前<span class="hljs-number">16</span>轮使用异或运算<br>    else:<br>        return (<span class="hljs-keyword">X</span> &amp; <span class="hljs-keyword">Y</span>) | (<span class="hljs-keyword">X</span> &amp; <span class="hljs-keyword">Z</span>) | (<span class="hljs-keyword">Y</span> &amp; <span class="hljs-keyword">Z</span>)  # 后<span class="hljs-number">48</span>轮使用多数函数<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：压缩函数中的逻辑函数</p><ul><li>前16轮：使用异或运算 <code>X ^ Y ^ Z</code></li><li>后48轮：使用多数函数 <code>(X &amp; Y) | (X &amp; Z) | (Y &amp; Z)</code></li></ul><h3 id="3-置换函数-P0-X"><a href="#3-置换函数-P0-X" class="headerlink" title="3. 置换函数 P0(X)"></a>3. 置换函数 <code>P0(X)</code></h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tp">def <span class="hljs-keyword">P</span><span class="hljs-number">0</span>(<span class="hljs-keyword">X</span>):<br>    return <span class="hljs-keyword">X</span> ^ LS(<span class="hljs-keyword">X</span>, <span class="hljs-number">9</span>) ^ LS(<span class="hljs-keyword">X</span>, <span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：用于压缩函数中的置换操作</p><ul><li>实现：<code>X ^ LS(X, 9) ^ LS(X, 17)</code></li><li>结合了循环左移和异或操作</li></ul><h3 id="4-置换函数-P1-X"><a href="#4-置换函数-P1-X" class="headerlink" title="4. 置换函数 P1(X)"></a>4. 置换函数 <code>P1(X)</code></h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tp">def <span class="hljs-keyword">P</span><span class="hljs-number">1</span>(<span class="hljs-keyword">X</span>):<br>    return <span class="hljs-keyword">X</span> ^ LS(<span class="hljs-keyword">X</span>, <span class="hljs-number">15</span>) ^ LS(<span class="hljs-keyword">X</span>, <span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：用于消息扩展中的置换操作</p><ul><li>实现：<code>X ^ LS(X, 15) ^ LS(X, 23)</code></li><li>在生成扩展消息字时使用</li></ul><h3 id="5-循环左移函数-LS-X-n"><a href="#5-循环左移函数-LS-X-n" class="headerlink" title="5. 循环左移函数 LS(X, n)"></a>5. 循环左移函数 <code>LS(X, n)</code></h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">LS</span>(<span class="hljs-params">X, n</span>):<br>    <span class="hljs-keyword">return</span> ((X &lt;&lt; n) &amp; <span class="hljs-number">0xFFFFFFFF</span>) |<span class="hljs-params"> (X &gt;&gt; (32 - n))</span><br></code></pre></td></tr></table></figure><p><strong>功能</strong>：实现32位数的循环左移</p><ul><li>保持32位边界，防止溢出</li></ul><h3 id="6-布尔函数-GG-X-Y-Z-j"><a href="#6-布尔函数-GG-X-Y-Z-j" class="headerlink" title="6. 布尔函数 GG(X, Y, Z, j)"></a>6. 布尔函数 <code>GG(X, Y, Z, j)</code></h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp">def GG(<span class="hljs-keyword">X</span>, <span class="hljs-keyword">Y</span>, <span class="hljs-keyword">Z</span>, j):<br>    if j &lt; <span class="hljs-number">16</span>:<br>        return <span class="hljs-keyword">X</span> ^ <span class="hljs-keyword">Y</span> ^ <span class="hljs-keyword">Z</span>  # 前<span class="hljs-number">16</span>轮使用异或运算<br>    else:<br>        return (<span class="hljs-keyword">X</span> &amp; <span class="hljs-keyword">Y</span>) | (~<span class="hljs-keyword">X</span> &amp; <span class="hljs-keyword">Z</span>)  # 后<span class="hljs-number">48</span>轮使用选择函数<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：压缩函数中的另一个逻辑函数</p><ul><li>前16轮：使用异或运算 <code>X ^ Y ^ Z</code></li><li>后48轮：使用选择函数 <code>(X &amp; Y) | (~X &amp; Z)</code></li></ul><h3 id="7-消息填充函数-pad-message"><a href="#7-消息填充函数-pad-message" class="headerlink" title="7. 消息填充函数 pad_message"></a>7. 消息填充函数 <code>pad_message</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pad_message</span>(<span class="hljs-params">message</span>):<br>    mlen1 = <span class="hljs-built_in">len</span>(message)  <span class="hljs-comment"># 原始消息长度</span><br>    <span class="hljs-built_in">print</span>(mlen1)<br>    mlen = mlen1<br>    message += <span class="hljs-string">b&#x27;\x80&#x27;</span>  <span class="hljs-comment"># 添加比特1</span><br>    mlen += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(mlen)<br>    <span class="hljs-comment"># 填充0直到长度满足 mod 64 = 56 L + 1 + k ≡ 448mod512 </span><br>    <span class="hljs-keyword">while</span> mlen % <span class="hljs-number">64</span> != <span class="hljs-number">56</span>:<br>        message += <span class="hljs-string">b&#x27;\x00&#x27;</span><br>        mlen += <span class="hljs-number">1</span><br>        <br>    <span class="hljs-comment"># 添加原始消息长度的64位表示</span><br>    message += (mlen1 * <span class="hljs-number">8</span>).to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;big&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(message)<br>    <span class="hljs-keyword">return</span> message<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：将输入消息填充到512位的倍数<br><strong>步骤</strong>：</p><ol><li>添加比特1 (<code>0x80</code>)</li><li>填充0直到长度满足 <code>L + 1 + k ≡ 448 mod 512</code></li><li>最后8字节添加原始消息的位长度</li></ol><h3 id="8-SM3压缩函数-SM3-CF-V-B-k"><a href="#8-SM3压缩函数-SM3-CF-V-B-k" class="headerlink" title="8. SM3压缩函数 SM3_CF(V, B, k)"></a>8. SM3压缩函数 <code>SM3_CF(V, B, k)</code></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs powershell">def SM3_CF(V, B, k):<br>    <span class="hljs-comment"># 消息扩展：生成132个字（68个W和64个W&#x27;）</span><br>    W = [<span class="hljs-number">0</span>] * <span class="hljs-number">68</span><br>    W_ = [<span class="hljs-number">0</span>] * <span class="hljs-number">64</span><br>    <br>    <span class="hljs-comment"># 前16个字直接从消息块中获取</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">16</span>):<br>        W[<span class="hljs-type">i</span>] = int.from_bytes(B[<span class="hljs-type">i</span>*<span class="hljs-number">4</span>:<span class="hljs-type">i</span>*<span class="hljs-number">4</span>+<span class="hljs-number">4</span>], <span class="hljs-string">&#x27;big&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 扩展生成后续的52个字</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">16</span>, <span class="hljs-number">68</span>):<br>        W[<span class="hljs-type">i</span>] = P1(W[<span class="hljs-type">i</span>-<span class="hljs-number">16</span>] ^ W[<span class="hljs-type">i</span>-<span class="hljs-number">9</span>] ^ <span class="hljs-built_in">LS</span>(W[<span class="hljs-type">i</span>-<span class="hljs-number">3</span>], <span class="hljs-number">15</span>)) ^ <span class="hljs-built_in">LS</span>(W[<span class="hljs-type">i</span>-<span class="hljs-number">13</span>], <span class="hljs-number">7</span>) ^ W[<span class="hljs-type">i</span>-<span class="hljs-number">6</span>]<br>    <br>    <span class="hljs-comment"># 生成W&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">64</span>):<br>        W_[<span class="hljs-type">i</span>] = W[<span class="hljs-type">i</span>] ^ W[<span class="hljs-type">i</span>+<span class="hljs-number">4</span>]<br>    <br>    <span class="hljs-comment"># 初始化8个工作变量</span><br>    A, B, C, D, E, F, G, <span class="hljs-built_in">H</span> = V<br>    <br>    <span class="hljs-comment"># 64轮压缩迭代</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">64</span>):<br>        <span class="hljs-comment"># 计算SS1和SS2</span><br>        SS1 = <span class="hljs-built_in">LS</span>((<span class="hljs-built_in">LS</span>(A, <span class="hljs-number">12</span>) + E + <span class="hljs-built_in">LS</span>(T(i), i % <span class="hljs-number">32</span>)) &amp; <span class="hljs-number">0</span>xFFFFFFFF, <span class="hljs-number">7</span>)<br>        SS2 = SS1 ^ <span class="hljs-built_in">LS</span>(A, <span class="hljs-number">12</span>)<br>        <br>        <span class="hljs-comment"># 计算TT1和TT2</span><br>        TT1 = (FF(A, B, C, i) + D + SS2 + W_[<span class="hljs-type">i</span>]) &amp; <span class="hljs-number">0</span>xFFFFFFFF<br>        TT2 = (GG(E, F, G, i) + <span class="hljs-built_in">H</span> + SS1 + W[<span class="hljs-type">i</span>]) &amp; <span class="hljs-number">0</span>xFFFFFFFF<br>        <br>        <span class="hljs-comment"># 更新寄存器值</span><br>        D = C<br>        C = <span class="hljs-built_in">LS</span>(B, <span class="hljs-number">9</span>)<br>        B = A<br>        A = TT1<br>        <span class="hljs-built_in">H</span> = G<br>        G = <span class="hljs-built_in">LS</span>(F, <span class="hljs-number">19</span>)<br>        F = E<br>        E = P0(TT2)<br>    <br>    <span class="hljs-keyword">return</span> A, B, C, D, E, F, G, <span class="hljs-built_in">H</span><br></code></pre></td></tr></table></figure><p><strong>功能</strong>：核心的压缩处理函数<br><strong>主要流程</strong>：</p><ul><li><strong>消息扩展</strong>：将512位消息块扩展为132个字（68个W + 64个W’）</li><li><strong>64轮迭代</strong>：每轮更新8个工作寄存器(A-H)</li><li>使用SS1、SS2、TT1、TT2等中间变量进行计算</li></ul><h3 id="9-T函数-T-j"><a href="#9-T函数-T-j" class="headerlink" title="9. T函数 T(j)"></a>9. T函数 <code>T(j)</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">T</span>(<span class="hljs-params">j</span>):<br>    <span class="hljs-keyword">if</span> j &lt; <span class="hljs-number">16</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0x79CC4519</span>  <span class="hljs-comment"># 前16轮使用的常量</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0x7A879D8A</span>  <span class="hljs-comment"># 后48轮使用的常量</span><br></code></pre></td></tr></table></figure><p><strong>功能</strong>：生成压缩函数中使用的常量</p><ul><li>前16轮：<code>0x79CC4519</code></li><li>后48轮：<code>0x7A879D8A</code></li></ul><h3 id="10-辅助函数"><a href="#10-辅助函数" class="headerlink" title="10. 辅助函数"></a>10. 辅助函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">string_to_ascii</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">ord</span>(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">or_16</span>(<span class="hljs-params">A, B</span>):<br>    A = <span class="hljs-built_in">int</span>(A, <span class="hljs-number">16</span>)<br>    B = <span class="hljs-built_in">int</span>(B, <span class="hljs-number">16</span>)<br>    C = A ^ B<br>    C = <span class="hljs-string">&#x27;&#123;:08x&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(C)<br>    <span class="hljs-keyword">return</span> C<br></code></pre></td></tr></table></figure><ul><li><code>string_to_ascii(s)</code>：字符串转ASCII码列表</li><li><code>or_16(A, B)</code>：16进制数的异或操作</li></ul><h3 id="11-主函数-SM3-message"><a href="#11-主函数-SM3-message" class="headerlink" title="11. 主函数 SM3(message)"></a>11. 主函数 <code>SM3(message)</code></h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def SM3(message):<br>    <span class="hljs-comment"># 将输入字符串转换为字节</span><br>    ascii_values = string_to_ascii(message)<br>    message_bytes = <span class="hljs-keyword">bytes</span>(ascii_values)<br>    <br>    <span class="hljs-comment"># 对消息进行填充</span><br>    padded_message = pad_message(message_bytes)<br>    <br>    <span class="hljs-comment"># 初始化哈希值</span><br>    <span class="hljs-built_in">result</span> = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> IV:<br>        <span class="hljs-built_in">result</span> += <span class="hljs-string">&#x27;&#123;:08x&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)<br>    <br>    V = IV.copy()<br>    <br>    <span class="hljs-comment"># 处理每个512位的消息块</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">len</span>(padded_message)<span class="hljs-comment"> // 64):</span><br>        B = padded_message[i*<span class="hljs-number">64</span>:(i+<span class="hljs-number">1</span>)*<span class="hljs-number">64</span>]  <span class="hljs-comment"># 获取当前消息块</span><br>        V = SM3_CF(V, B, i)  <span class="hljs-comment"># 调用压缩函数</span><br>        <br>        <span class="hljs-comment"># 更新哈希值</span><br>        all = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> iii <span class="hljs-keyword">in</span> V:<br>            all += <span class="hljs-string">&#x27;&#123;:08x&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(iii)<br>        <span class="hljs-built_in">result</span> = or_16(all, <span class="hljs-built_in">result</span>)<br> <br>    <span class="hljs-literal">return</span> <span class="hljs-built_in">result</span><br></code></pre></td></tr></table></figure><p><strong>功能</strong>：SM3哈希算法的主入口<br><strong>流程</strong>：</p><ol><li>字符串转字节</li><li>消息填充</li><li>分块处理（每个512位块）</li><li>调用压缩函数</li><li>合并哈希结果</li></ol><h1 id="四、SM3优缺点"><a href="#四、SM3优缺点" class="headerlink" title="四、SM3优缺点"></a>四、<strong>SM3优缺点</strong></h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h2><h3 id="1-国家安全战略与合规要求"><a href="#1-国家安全战略与合规要求" class="headerlink" title="1.国家安全战略与合规要求"></a>1.<strong>国家安全战略与合规要求</strong></h3><ul><li><strong>自主可控</strong>：作为中国自主研发的密码算法，SM3 减少了对国外密码算法的依赖，在关键信息基础设施、金融、政务等领域的使用符合国家网络安全和自主可控的战略要求。</li><li><strong>法规符合性</strong>：在国内许多行业（如金融、电力、交通等），使用国密算法是硬性规定。要进入这些市场，产品或系统必须支持 SM3。</li></ul><h3 id="2-较高的安全性"><a href="#2-较高的安全性" class="headerlink" title="2.较高的安全性"></a>2.<strong>较高的安全性</strong></h3><ul><li><strong>设计强度</strong>：SM3 的输出长度为 256 位，其设计安全强度与 SHA-256 相当，能够有效抵抗暴力碰撞攻击（需要约 2^128 次操作）。</li><li><strong>结构坚固</strong>：SM3 采用了成熟的 <strong>Merkle-Damgård 结构</strong>，并在此基础上进行了强化。它设计了复杂的布尔函数和移位操作，使得它能够有效抵抗已知的密码分析攻击，如长度扩展攻击、碰撞攻击等。截至目前，SM3 没有公开的、有效的安全漏洞。</li></ul><h3 id="3-良好的性能与效率"><a href="#3-良好的性能与效率" class="headerlink" title="3.良好的性能与效率"></a>3.<strong>良好的性能与效率</strong></h3><ul><li><strong>软件实现效率高</strong>：在通用 CPU 上，SM3 的运算速度与 SHA-256 处于同一水平，甚至在某些平台上通过优化可以实现更快的速度。</li><li><strong>硬件支持</strong>：目前已有许多国产密码芯片和硬件安全模块（HSM）对 SM3 提供了原生硬件加速，这使得在硬件层面执行 SM3 运算非常高效，远超软件实现。</li></ul><h3 id="4-完整的国密算法生态"><a href="#4-完整的国密算法生态" class="headerlink" title="4.完整的国密算法生态"></a>4.<strong>完整的国密算法生态</strong></h3><ul><li>SM3 与另外两个国密算法（SM2 非对称加密、SM4 对称加密）构成了一个完整的密码算法体系。它们经常被一起使用，例如，用 SM3 计算消息摘要，再用 SM2 对摘要进行数字签名。这种“全家桶”式的解决方案在国内生态中集成度和接受度很高。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h2><h3 id="1-国际接受度和普及度相对较低"><a href="#1-国际接受度和普及度相对较低" class="headerlink" title="1.国际接受度和普及度相对较低"></a>1.<strong>国际接受度和普及度相对较低</strong></h3><ul><li><strong>生态壁垒</strong>：在国际开源社区、主流软件库和跨国企业的系统中，SM3 的支持度远不如 SHA-256 等国际算法。这可能导致在跨国协作或全球化产品开发中遇到兼容性问题。</li><li><strong>“安全性通过晦涩”的质疑</strong>：尽管目前没有证据表明 SM3 存在后门或弱点，但因为它不像 SHA 家族那样经过全球密码学界长达数十年的公开、广泛的审视和攻击测试，部分国际密码专家对其持谨慎态度。这是一种常见的对于“未经历足够公开检验”的算法的合理性质疑。</li></ul><h3 id="2-算法复杂度相对较高"><a href="#2-算法复杂度相对较高" class="headerlink" title="2.算法复杂度相对较高"></a>2.<strong>算法复杂度相对较高</strong></h3><ul><li>与一些更简洁的算法相比，SM3 的轮函数和消息扩展步骤设计得相对复杂。这虽然增强了安全性，但也增加了实现和理解算法的难度，对于初学者或需要自行实现的开发者来说门槛稍高。</li></ul><h3 id="3-潜在的供应链依赖"><a href="#3-潜在的供应链依赖" class="headerlink" title="3.潜在的供应链依赖"></a>3.<strong>潜在的供应链依赖</strong></h3><ul><li>虽然 SM3 是为了“自主可控”，但对于中国以外的国家和公司来说，使用 SM3 意味着需要依赖中国的密码标准和相关技术生态，这可能会引发他们对于供应链和技术依赖的担忧。</li></ul><h3 id="4-历史与审查因素"><a href="#4-历史与审查因素" class="headerlink" title="4.历史与审查因素"></a>4.<strong>历史与审查因素</strong></h3><ul><li>算法的设计过程由国家密码管理局主导，其内部设计决策和选择标准并未像 NIST 组织设计 SHA-3 (Keccak) 那样完全公开并举办全球竞赛。这种相对不透明的诞生过程，是部分人对其持保留态度的历史原因。</li></ul><h1 id="五、-SM3算法的应用场景"><a href="#五、-SM3算法的应用场景" class="headerlink" title="**五、**SM3算法的应用场景"></a>**五、**SM3算法的应用场景</h1><h3 id="1-金融支付"><a href="#1-金融支付" class="headerlink" title="1.金融支付"></a>1.<strong>金融支付</strong></h3><p>在电子支付和网上银行系统中，SM3算法用于保障交易信息的完整性。当用户进行转账交易时，系统会使用SM3对交易报文（如金额、收款方、时间戳等关键数据）生成唯一的数字指纹（哈希值），并与SM2数字签名结合使用。任何对交易数据的细微篡改都会导致哈希值完全不同，从而使签名验证失败，银行因此能够及时发现并拒绝非法交易，有效防止数据在传输过程中被恶意篡改。</p><h3 id="2-电子政务"><a href="#2-电子政务" class="headerlink" title="2.电子政务"></a>2.<strong>电子政务</strong></h3><p>在电子证照和公文流转领域，SM3算法是验证文件真实性与完整性的核心。例如，在签发电子营业执照时，发证机关会使用SM3算法对证照信息生成摘要，并通过数字签名技术将其固定。查验方只需重新计算证照的SM3值并与官方签名进行比对，即可快速、准确地验证证照是否被伪造或篡改，确保了电子公文和证照的法律效力与可信度。</p><h3 id="3-物联网安全"><a href="#3-物联网安全" class="headerlink" title="3.物联网安全"></a>3.<strong>物联网安全</strong></h3><p>对于海量的物联网设备，如智能电表，SM3算法用于实现安全的数据采集。电表在上传用电量数据时，会使用预共享的密钥与SM3算法生成消息认证码（MAC）并附加在报文中。数据中心接收到数据后，执行相同的计算来验证MAC的正确性。这种方式能有效识别并拒绝攻击者伪造或篡改的虚假数据，保障了计量数据的真实性和计费的准确性。</p><h3 id="4-区块链与版权保护"><a href="#4-区块链与版权保护" class="headerlink" title="4.区块链与版权保护"></a>4.<strong>区块链与版权保护</strong></h3><p>在国产区块链和数字版权平台中，SM3算法构成了数据不可篡改特性的基础。每个区块的交易信息都会通过SM3计算生成唯一的哈希值，并链接到下一个区块。一旦某个区块内的交易被修改，其哈希值就会改变，从而导致整个后续链失效。同样，原创者可以将作品的SM3哈希值存入区块链，作为其在特定时间点存在的、未经篡改的唯一数字指纹，为后续的版权确认与维权提供铁证。</p><h3 id="5-软件与系统安全"><a href="#5-软件与系统安全" class="headerlink" title="5.软件与系统安全"></a>5.<strong>软件与系统安全</strong></h3><p>在软件分发和系统完整性保护方面，SM3算法发挥着关键作用。软件开发商在发布安装包或固件时，会同时公布其SM3哈希值。用户下载后，可自行计算文件的SM3值并与官方值进行比对，以此验证文件在下载过程中是否完好无损，未被植入木马或病毒。在企业内部，系统管理员也可以通过定期计算关键系统文件的SM3哈希值，来检测文件是否被非法修改，从而确保系统环境的可信。</p><h1 id="六、-总结"><a href="#六、-总结" class="headerlink" title="**六、**总结"></a>**六、**总结</h1><p>SM3算法作为我国商用密码体系的核心基石，是由国家密码管理局自主设计并发布的密码杂凑算法。该算法通过生成唯一的256位”数字指纹”，为各类数字应用提供关键的安全保障。在技术层面，SM3采用强化设计的Merkle-Damgård结构，具备与SHA-256相当的安全强度，能有效抵抗各类密码攻击，同时保持了优异的运算性能。其应用已深度渗透到金融交易、电子政务、物联网、区块链等关键领域，不仅确保数据传输的完整性和真实性，更为数字身份认证、电子签名等场景提供可靠支撑。随着数字中国建设的深入推进，SM3在保障关键信息基础设施安全、维护数字经济秩序等方面发挥着不可替代的作用，已成为构建自主可控网络安全体系的战略支撑技术</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码</title>
    <link href="/2025/10/29/%E5%AF%86%E7%A0%81/%E5%AF%86%E7%A0%81/"/>
    <url>/2025/10/29/%E5%AF%86%E7%A0%81/%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="国密SM3算法"><a href="#国密SM3算法" class="headerlink" title="国密SM3算法"></a><strong>国密SM3算法</strong></h1><h2 id="一、概述及其特点"><a href="#一、概述及其特点" class="headerlink" title="一、概述及其特点"></a>一、<strong>概述及其特点</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>​       SM3密码杂凑算法是中国国家密码管理局2010年公布的中国商用密码杂凑算法标准。具体算法标准原始文本参见参考文献[1]。该算法于2012年发布为密码行业标准(<a href="https://zhida.zhihu.com/search?content_id=116951744&content_type=Article&match_order=1&q=GM/T+0004-2012&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjE4MzA3OTUsInEiOiJHTS9UIDAwMDQtMjAxMiIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjExNjk1MTc0NCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.FshGANoIJ-jTtsSBN7B2UjeRKLaHIJCG2fUIMiFa528&zhida_source=entity">GM&#x2F;T 0004-2012</a>)，2016年发布为国家密码杂凑算法标准(<a href="https://zhida.zhihu.com/search?content_id=116951744&content_type=Article&match_order=1&q=GB/T+32905-2016&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjE4MzA3OTUsInEiOiJHQi9UIDMyOTA1LTIwMTYiLCJ6aGlkYV9zb3VyY2UiOiJlbnRpdHkiLCJjb250ZW50X2lkIjoxMTY5NTE3NDQsImNvbnRlbnRfdHlwZSI6IkFydGljbGUiLCJtYXRjaF9vcmRlciI6MSwiemRfdG9rZW4iOm51bGx9.f7-uwJHh03jvb_ZQk-tS8Nz2NfJLY4Lr0wkzLQfuKUI&zhida_source=entity">GB&#x2F;T 32905-2016</a>)。</p><p>​      SM3适用于商用密码应用中的数字签名和验证，是在SHA-256基础上改进实现的一种算法，其安全性和SHA-256相当。SM3和MD5的迭代过程类似，也采用<a href="https://zhida.zhihu.com/search?content_id=116951744&content_type=Article&match_order=1&q=Merkle-Damgard%E7%BB%93%E6%9E%84&zd_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJ6aGlkYV9zZXJ2ZXIiLCJleHAiOjE3NjE4MzA3OTUsInEiOiJNZXJrbGUtRGFtZ2FyZOe7k-aehCIsInpoaWRhX3NvdXJjZSI6ImVudGl0eSIsImNvbnRlbnRfaWQiOjExNjk1MTc0NCwiY29udGVudF90eXBlIjoiQXJ0aWNsZSIsIm1hdGNoX29yZGVyIjoxLCJ6ZF90b2tlbiI6bnVsbH0.o1N5_yHjLtI7fWzWLIBIjNvF5xnIdMavEQ6UxK3e1Uo&zhida_source=entity">Merkle-Damgard结构</a>。消息分组长度为512位，摘要值长度为256位。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>固定长度输出：SM3对任意长度的输入消息，均生成固定长度为256位的杂凑值，具备抗碰撞、抗第二原像等安全特性，确保数据完整性与唯一性。</li><li>结构与安全性：采用成熟的Merkle-Damgård结构，具备强雪崩效应，输入微小变动会导致输出显著不同，有效抵御密码分析攻击。</li><li>高效性：算法设计兼顾软硬件实现效率，运算过程基于位操作与逻辑函数，适用于资源受限的物联网设备、嵌入式系统及高性能服务器。</li><li>广泛用途：作为基础密码组件，SM3常用于数字签名、消息认证码生成、随机数生成及数据完整性校验，是实现身份鉴别与防篡改的核心工具。</li></ul><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a><strong>组成部分</strong></h3><ol><li><strong>数据填充</strong><br>将任意长度的消息填充为512位的整数倍，并在末尾附加原始长度。</li><li><strong>消息扩展</strong><br>将每个512位的分组扩展生成132个字，用于后续计算，以消除数据规律。</li><li><strong>压缩函数（核心）</strong><br>将扩展后的消息与中间结果进行64轮混合运算，充分打乱数据，生成新的哈希值。</li><li><strong>迭代结构</strong><br>按顺序将每个填充后的分组送入压缩函数进行处理，最后一个输出的结果就是最终的SM3哈希值。</li></ol><h3 id="算法核心"><a href="#算法核心" class="headerlink" title="算法核心"></a>算法核心</h3><ol><li><strong>压缩函数</strong><ul><li>这是SM3的<strong>绝对核心</strong>，是一个单向的“数据搅拌器”。</li><li>它将一个512位的消息分组和当前的256位中间状态值进行混合，通过64轮复杂的数学运算（包括位运算、模加等），输出一个新的256位中间状态值。</li><li>它确保了数据的任何微小变化都会扩散到整个输出中。</li></ul></li><li><strong>迭代结构</strong><ul><li>它定义了如何用“压缩函数”处理长消息，即**“分块处理，链式连接”**。</li><li>算法将填充后的消息切成多个512位的块。第一个块与一个固定的<strong>初始值</strong>一起压缩，产生的输出作为下一个块的输入，如此反复。最后一个块的输出就是最终的哈希值。</li></ul></li><li><strong>消息扩展</strong><ul><li>这是压缩函数的“燃料准备”阶段。</li><li>它将一个512位的输入块扩展成132个更小的数据单元，为64轮运算提供“弹药”。这个过程本身也增加了数据的随机性和依赖性，进一步增强了安全性。</li></ul></li></ol><h2 id="二、大致流程"><a href="#二、大致流程" class="headerlink" title="二、大致流程"></a><strong>二、大致流程</strong></h2><h3 id="第一步：消息填充"><a href="#第一步：消息填充" class="headerlink" title="第一步：消息填充"></a><strong>第一步：消息填充</strong></h3><ol><li><strong>添加比特’1’</strong>：在原始消息的末尾首先添加一个二进制的<code>1</code>。</li><li><strong>添加k个比特’0’</strong>：<code>k</code>是满足以下等式的最小非负整数：<br><code>(原始消息长度(位) + 1 + k) ≡ 448 (mod 512)</code><br>这确保了填充后（还未加长度信息）的消息长度恰好比512位的整数倍少64位。</li><li><strong>附加长度信息</strong>：在末尾添加一个64位的字段，用来表示<strong>原始消息的二进制位长度</strong></li></ol><h3 id="第二步：消息扩展"><a href="#第二步：消息扩展" class="headerlink" title="第二步：消息扩展"></a><strong>第二步：消息扩展</strong></h3><p>SM3的迭代压缩步骤没有直接使用数据分组进行运算，而是使用这个步骤产生的132个消息字。（一个消息字的长度为32位&#x2F;4个字节&#x2F;8个16j进制数字）概括来说，先将一个512位数据分组划分为16个消息字，并且作为生成的132个消息字的前16个。再用这16个消息字递推生成剩余的116个消息字。</p><p>在最终得到的132个消息字中，前68个消息字构成数列 {W j {W_j}Wj}，后64个消息字构成数列 {W j ‘ {W_j^&#96;}Wj‘}，其中下标j从0开始计数。</p><h3 id="第三步：迭代压缩"><a href="#第三步：迭代压缩" class="headerlink" title="第三步：迭代压缩"></a><strong>第三步：迭代压缩</strong></h3><p><img src="https://jxdgx.oss-cn-beijing.aliyuncs.com/image-20251028225529828.png" alt="image-20251028225529828"></p><p>最后，再将计算完成的A、B、C、D、E、F、G、H和原来的A、B、C、D、E、F、G、H分别进行异或，就是压缩函数的输出。这个输出再作为下一次调用压缩函数时的初值。依次类推，直到用完最后一组132个消息字为止。</p><h3 id="第四步：输出结果"><a href="#第四步：输出结果" class="headerlink" title="第四步：输出结果"></a><strong>第四步：输出结果</strong></h3><p>将得到的A、B、C、D、E、F、G、H八个变量拼接输出，就是SM3算法的输出。</p><h2 id="三-SM3加密"><a href="#三-SM3加密" class="headerlink" title="三. SM3加密"></a>三. <strong>SM3加密</strong></h2><p>SM3是中国国家密码管理局发布的密码杂凑算法标准，用于生成256位（32字节）的哈希值。代码实现了SM3算法的所有核心组件：消息填充、消息扩展、压缩函数和迭代哈希计算。</p><h3 id="1-初始向量-IV"><a href="#1-初始向量-IV" class="headerlink" title="1. 初始向量 IV"></a>1. 初始向量 <code>IV</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">IV = [<br>    <span class="hljs-number">0x7380166F</span>, <span class="hljs-number">0x4914B2B9</span>, <span class="hljs-number">0x172442D7</span>, <span class="hljs-number">0xDA8A0600</span>,<br>    <span class="hljs-number">0xA96F30BC</span>, <span class="hljs-number">0x163138AA</span>, <span class="hljs-number">0xE38DEE4D</span>, <span class="hljs-number">0xB0FB0E4E</span><br>]<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：SM3算法的初始哈希值，包含8个32位字，作为哈希计算的起点。</p><h3 id="2-布尔函数-FF-X-Y-Z-j"><a href="#2-布尔函数-FF-X-Y-Z-j" class="headerlink" title="2. 布尔函数 FF(X, Y, Z, j)"></a>2. 布尔函数 <code>FF(X, Y, Z, j)</code></h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp">def FF(<span class="hljs-keyword">X</span>, <span class="hljs-keyword">Y</span>, <span class="hljs-keyword">Z</span>, j):<br>    if j &lt; <span class="hljs-number">16</span>:<br>        return <span class="hljs-keyword">X</span> ^ <span class="hljs-keyword">Y</span> ^ <span class="hljs-keyword">Z</span>  # 前<span class="hljs-number">16</span>轮使用异或运算<br>    else:<br>        return (<span class="hljs-keyword">X</span> &amp; <span class="hljs-keyword">Y</span>) | (<span class="hljs-keyword">X</span> &amp; <span class="hljs-keyword">Z</span>) | (<span class="hljs-keyword">Y</span> &amp; <span class="hljs-keyword">Z</span>)  # 后<span class="hljs-number">48</span>轮使用多数函数<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：压缩函数中的逻辑函数</p><ul><li>前16轮：使用异或运算 <code>X ^ Y ^ Z</code></li><li>后48轮：使用多数函数 <code>(X &amp; Y) | (X &amp; Z) | (Y &amp; Z)</code></li></ul><h3 id="3-置换函数-P0-X"><a href="#3-置换函数-P0-X" class="headerlink" title="3. 置换函数 P0(X)"></a>3. 置换函数 <code>P0(X)</code></h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tp">def <span class="hljs-keyword">P</span><span class="hljs-number">0</span>(<span class="hljs-keyword">X</span>):<br>    return <span class="hljs-keyword">X</span> ^ LS(<span class="hljs-keyword">X</span>, <span class="hljs-number">9</span>) ^ LS(<span class="hljs-keyword">X</span>, <span class="hljs-number">17</span>)<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：用于压缩函数中的置换操作</p><ul><li>实现：<code>X ^ LS(X, 9) ^ LS(X, 17)</code></li><li>结合了循环左移和异或操作</li></ul><h3 id="4-置换函数-P1-X"><a href="#4-置换函数-P1-X" class="headerlink" title="4. 置换函数 P1(X)"></a>4. 置换函数 <code>P1(X)</code></h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tp">def <span class="hljs-keyword">P</span><span class="hljs-number">1</span>(<span class="hljs-keyword">X</span>):<br>    return <span class="hljs-keyword">X</span> ^ LS(<span class="hljs-keyword">X</span>, <span class="hljs-number">15</span>) ^ LS(<span class="hljs-keyword">X</span>, <span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：用于消息扩展中的置换操作</p><ul><li>实现：<code>X ^ LS(X, 15) ^ LS(X, 23)</code></li><li>在生成扩展消息字时使用</li></ul><h3 id="5-循环左移函数-LS-X-n"><a href="#5-循环左移函数-LS-X-n" class="headerlink" title="5. 循环左移函数 LS(X, n)"></a>5. 循环左移函数 <code>LS(X, n)</code></h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">def</span> <span class="hljs-title function_">LS</span>(<span class="hljs-params">X, n</span>):<br>    <span class="hljs-keyword">return</span> ((X &lt;&lt; n) &amp; <span class="hljs-number">0xFFFFFFFF</span>) |<span class="hljs-params"> (X &gt;&gt; (32 - n))</span><br></code></pre></td></tr></table></figure><p><strong>功能</strong>：实现32位数的循环左移</p><ul><li>保持32位边界，防止溢出</li></ul><h3 id="6-布尔函数-GG-X-Y-Z-j"><a href="#6-布尔函数-GG-X-Y-Z-j" class="headerlink" title="6. 布尔函数 GG(X, Y, Z, j)"></a>6. 布尔函数 <code>GG(X, Y, Z, j)</code></h3><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp">def GG(<span class="hljs-keyword">X</span>, <span class="hljs-keyword">Y</span>, <span class="hljs-keyword">Z</span>, j):<br>    if j &lt; <span class="hljs-number">16</span>:<br>        return <span class="hljs-keyword">X</span> ^ <span class="hljs-keyword">Y</span> ^ <span class="hljs-keyword">Z</span>  # 前<span class="hljs-number">16</span>轮使用异或运算<br>    else:<br>        return (<span class="hljs-keyword">X</span> &amp; <span class="hljs-keyword">Y</span>) | (~<span class="hljs-keyword">X</span> &amp; <span class="hljs-keyword">Z</span>)  # 后<span class="hljs-number">48</span>轮使用选择函数<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：压缩函数中的另一个逻辑函数</p><ul><li>前16轮：使用异或运算 <code>X ^ Y ^ Z</code></li><li>后48轮：使用选择函数 <code>(X &amp; Y) | (~X &amp; Z)</code></li></ul><h3 id="7-消息填充函数-pad-message"><a href="#7-消息填充函数-pad-message" class="headerlink" title="7. 消息填充函数 pad_message"></a>7. 消息填充函数 <code>pad_message</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pad_message</span>(<span class="hljs-params">message</span>):<br>    mlen1 = <span class="hljs-built_in">len</span>(message)  <span class="hljs-comment"># 原始消息长度</span><br>    <span class="hljs-built_in">print</span>(mlen1)<br>    mlen = mlen1<br>    message += <span class="hljs-string">b&#x27;\x80&#x27;</span>  <span class="hljs-comment"># 添加比特1</span><br>    mlen += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(mlen)<br>    <span class="hljs-comment"># 填充0直到长度满足 mod 64 = 56 L + 1 + k ≡ 448mod512 </span><br>    <span class="hljs-keyword">while</span> mlen % <span class="hljs-number">64</span> != <span class="hljs-number">56</span>:<br>        message += <span class="hljs-string">b&#x27;\x00&#x27;</span><br>        mlen += <span class="hljs-number">1</span><br>        <br>    <span class="hljs-comment"># 添加原始消息长度的64位表示</span><br>    message += (mlen1 * <span class="hljs-number">8</span>).to_bytes(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;big&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(message)<br>    <span class="hljs-keyword">return</span> message<br></code></pre></td></tr></table></figure><p><strong>功能</strong>：将输入消息填充到512位的倍数<br><strong>步骤</strong>：</p><ol><li>添加比特1 (<code>0x80</code>)</li><li>填充0直到长度满足 <code>L + 1 + k ≡ 448 mod 512</code></li><li>最后8字节添加原始消息的位长度</li></ol><h3 id="8-SM3压缩函数-SM3-CF-V-B-k"><a href="#8-SM3压缩函数-SM3-CF-V-B-k" class="headerlink" title="8. SM3压缩函数 SM3_CF(V, B, k)"></a>8. SM3压缩函数 <code>SM3_CF(V, B, k)</code></h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs powershell">def SM3_CF(V, B, k):<br>    <span class="hljs-comment"># 消息扩展：生成132个字（68个W和64个W&#x27;）</span><br>    W = [<span class="hljs-number">0</span>] * <span class="hljs-number">68</span><br>    W_ = [<span class="hljs-number">0</span>] * <span class="hljs-number">64</span><br>    <br>    <span class="hljs-comment"># 前16个字直接从消息块中获取</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">16</span>):<br>        W[<span class="hljs-type">i</span>] = int.from_bytes(B[<span class="hljs-type">i</span>*<span class="hljs-number">4</span>:<span class="hljs-type">i</span>*<span class="hljs-number">4</span>+<span class="hljs-number">4</span>], <span class="hljs-string">&#x27;big&#x27;</span>)<br>    <br>    <span class="hljs-comment"># 扩展生成后续的52个字</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">16</span>, <span class="hljs-number">68</span>):<br>        W[<span class="hljs-type">i</span>] = P1(W[<span class="hljs-type">i</span>-<span class="hljs-number">16</span>] ^ W[<span class="hljs-type">i</span>-<span class="hljs-number">9</span>] ^ <span class="hljs-built_in">LS</span>(W[<span class="hljs-type">i</span>-<span class="hljs-number">3</span>], <span class="hljs-number">15</span>)) ^ <span class="hljs-built_in">LS</span>(W[<span class="hljs-type">i</span>-<span class="hljs-number">13</span>], <span class="hljs-number">7</span>) ^ W[<span class="hljs-type">i</span>-<span class="hljs-number">6</span>]<br>    <br>    <span class="hljs-comment"># 生成W&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">64</span>):<br>        W_[<span class="hljs-type">i</span>] = W[<span class="hljs-type">i</span>] ^ W[<span class="hljs-type">i</span>+<span class="hljs-number">4</span>]<br>    <br>    <span class="hljs-comment"># 初始化8个工作变量</span><br>    A, B, C, D, E, F, G, <span class="hljs-built_in">H</span> = V<br>    <br>    <span class="hljs-comment"># 64轮压缩迭代</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">64</span>):<br>        <span class="hljs-comment"># 计算SS1和SS2</span><br>        SS1 = <span class="hljs-built_in">LS</span>((<span class="hljs-built_in">LS</span>(A, <span class="hljs-number">12</span>) + E + <span class="hljs-built_in">LS</span>(T(i), i % <span class="hljs-number">32</span>)) &amp; <span class="hljs-number">0</span>xFFFFFFFF, <span class="hljs-number">7</span>)<br>        SS2 = SS1 ^ <span class="hljs-built_in">LS</span>(A, <span class="hljs-number">12</span>)<br>        <br>        <span class="hljs-comment"># 计算TT1和TT2</span><br>        TT1 = (FF(A, B, C, i) + D + SS2 + W_[<span class="hljs-type">i</span>]) &amp; <span class="hljs-number">0</span>xFFFFFFFF<br>        TT2 = (GG(E, F, G, i) + <span class="hljs-built_in">H</span> + SS1 + W[<span class="hljs-type">i</span>]) &amp; <span class="hljs-number">0</span>xFFFFFFFF<br>        <br>        <span class="hljs-comment"># 更新寄存器值</span><br>        D = C<br>        C = <span class="hljs-built_in">LS</span>(B, <span class="hljs-number">9</span>)<br>        B = A<br>        A = TT1<br>        <span class="hljs-built_in">H</span> = G<br>        G = <span class="hljs-built_in">LS</span>(F, <span class="hljs-number">19</span>)<br>        F = E<br>        E = P0(TT2)<br>    <br>    <span class="hljs-keyword">return</span> A, B, C, D, E, F, G, <span class="hljs-built_in">H</span><br></code></pre></td></tr></table></figure><p><strong>功能</strong>：核心的压缩处理函数<br><strong>主要流程</strong>：</p><ul><li><strong>消息扩展</strong>：将512位消息块扩展为132个字（68个W + 64个W’）</li><li><strong>64轮迭代</strong>：每轮更新8个工作寄存器(A-H)</li><li>使用SS1、SS2、TT1、TT2等中间变量进行计算</li></ul><h3 id="9-T函数-T-j"><a href="#9-T函数-T-j" class="headerlink" title="9. T函数 T(j)"></a>9. T函数 <code>T(j)</code></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">T</span>(<span class="hljs-params">j</span>):<br>    <span class="hljs-keyword">if</span> j &lt; <span class="hljs-number">16</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0x79CC4519</span>  <span class="hljs-comment"># 前16轮使用的常量</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0x7A879D8A</span>  <span class="hljs-comment"># 后48轮使用的常量</span><br></code></pre></td></tr></table></figure><p><strong>功能</strong>：生成压缩函数中使用的常量</p><ul><li>前16轮：<code>0x79CC4519</code></li><li>后48轮：<code>0x7A879D8A</code></li></ul><h3 id="10-辅助函数"><a href="#10-辅助函数" class="headerlink" title="10. 辅助函数"></a>10. 辅助函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">string_to_ascii</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">ord</span>(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s]<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">or_16</span>(<span class="hljs-params">A, B</span>):<br>    A = <span class="hljs-built_in">int</span>(A, <span class="hljs-number">16</span>)<br>    B = <span class="hljs-built_in">int</span>(B, <span class="hljs-number">16</span>)<br>    C = A ^ B<br>    C = <span class="hljs-string">&#x27;&#123;:08x&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(C)<br>    <span class="hljs-keyword">return</span> C<br></code></pre></td></tr></table></figure><ul><li><code>string_to_ascii(s)</code>：字符串转ASCII码列表</li><li><code>or_16(A, B)</code>：16进制数的异或操作</li></ul><h3 id="11-主函数-SM3-message"><a href="#11-主函数-SM3-message" class="headerlink" title="11. 主函数 SM3(message)"></a>11. 主函数 <code>SM3(message)</code></h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def SM3(message):<br>    <span class="hljs-comment"># 将输入字符串转换为字节</span><br>    ascii_values = string_to_ascii(message)<br>    message_bytes = <span class="hljs-keyword">bytes</span>(ascii_values)<br>    <br>    <span class="hljs-comment"># 对消息进行填充</span><br>    padded_message = pad_message(message_bytes)<br>    <br>    <span class="hljs-comment"># 初始化哈希值</span><br>    <span class="hljs-built_in">result</span> = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> IV:<br>        <span class="hljs-built_in">result</span> += <span class="hljs-string">&#x27;&#123;:08x&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(i)<br>    <br>    V = IV.copy()<br>    <br>    <span class="hljs-comment"># 处理每个512位的消息块</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-built_in">len</span>(padded_message)<span class="hljs-comment"> // 64):</span><br>        B = padded_message[i*<span class="hljs-number">64</span>:(i+<span class="hljs-number">1</span>)*<span class="hljs-number">64</span>]  <span class="hljs-comment"># 获取当前消息块</span><br>        V = SM3_CF(V, B, i)  <span class="hljs-comment"># 调用压缩函数</span><br>        <br>        <span class="hljs-comment"># 更新哈希值</span><br>        all = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-keyword">for</span> iii <span class="hljs-keyword">in</span> V:<br>            all += <span class="hljs-string">&#x27;&#123;:08x&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(iii)<br>        <span class="hljs-built_in">result</span> = or_16(all, <span class="hljs-built_in">result</span>)<br> <br>    <span class="hljs-literal">return</span> <span class="hljs-built_in">result</span><br></code></pre></td></tr></table></figure><p><strong>功能</strong>：SM3哈希算法的主入口<br><strong>流程</strong>：</p><ol><li>字符串转字节</li><li>消息填充</li><li>分块处理（每个512位块）</li><li>调用压缩函数</li><li>合并哈希结果</li></ol><h1 id="四、SM3优缺点"><a href="#四、SM3优缺点" class="headerlink" title="四、SM3优缺点"></a>四、<strong>SM3优缺点</strong></h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a><strong>优点</strong></h2><h3 id="1-国家安全战略与合规要求"><a href="#1-国家安全战略与合规要求" class="headerlink" title="1.国家安全战略与合规要求"></a>1.<strong>国家安全战略与合规要求</strong></h3><ul><li><strong>自主可控</strong>：作为中国自主研发的密码算法，SM3 减少了对国外密码算法的依赖，在关键信息基础设施、金融、政务等领域的使用符合国家网络安全和自主可控的战略要求。</li><li><strong>法规符合性</strong>：在国内许多行业（如金融、电力、交通等），使用国密算法是硬性规定。要进入这些市场，产品或系统必须支持 SM3。</li></ul><h3 id="2-较高的安全性"><a href="#2-较高的安全性" class="headerlink" title="2.较高的安全性"></a>2.<strong>较高的安全性</strong></h3><ul><li><strong>设计强度</strong>：SM3 的输出长度为 256 位，其设计安全强度与 SHA-256 相当，能够有效抵抗暴力碰撞攻击（需要约 2^128 次操作）。</li><li><strong>结构坚固</strong>：SM3 采用了成熟的 <strong>Merkle-Damgård 结构</strong>，并在此基础上进行了强化。它设计了复杂的布尔函数和移位操作，使得它能够有效抵抗已知的密码分析攻击，如长度扩展攻击、碰撞攻击等。截至目前，SM3 没有公开的、有效的安全漏洞。</li></ul><h3 id="3-良好的性能与效率"><a href="#3-良好的性能与效率" class="headerlink" title="3.良好的性能与效率"></a>3.<strong>良好的性能与效率</strong></h3><ul><li><strong>软件实现效率高</strong>：在通用 CPU 上，SM3 的运算速度与 SHA-256 处于同一水平，甚至在某些平台上通过优化可以实现更快的速度。</li><li><strong>硬件支持</strong>：目前已有许多国产密码芯片和硬件安全模块（HSM）对 SM3 提供了原生硬件加速，这使得在硬件层面执行 SM3 运算非常高效，远超软件实现。</li></ul><h3 id="4-完整的国密算法生态"><a href="#4-完整的国密算法生态" class="headerlink" title="4.完整的国密算法生态"></a>4.<strong>完整的国密算法生态</strong></h3><ul><li>SM3 与另外两个国密算法（SM2 非对称加密、SM4 对称加密）构成了一个完整的密码算法体系。它们经常被一起使用，例如，用 SM3 计算消息摘要，再用 SM2 对摘要进行数字签名。这种“全家桶”式的解决方案在国内生态中集成度和接受度很高。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><strong>缺点</strong></h2><h3 id="1-国际接受度和普及度相对较低"><a href="#1-国际接受度和普及度相对较低" class="headerlink" title="1.国际接受度和普及度相对较低"></a>1.<strong>国际接受度和普及度相对较低</strong></h3><ul><li><strong>生态壁垒</strong>：在国际开源社区、主流软件库和跨国企业的系统中，SM3 的支持度远不如 SHA-256 等国际算法。这可能导致在跨国协作或全球化产品开发中遇到兼容性问题。</li><li><strong>“安全性通过晦涩”的质疑</strong>：尽管目前没有证据表明 SM3 存在后门或弱点，但因为它不像 SHA 家族那样经过全球密码学界长达数十年的公开、广泛的审视和攻击测试，部分国际密码专家对其持谨慎态度。这是一种常见的对于“未经历足够公开检验”的算法的合理性质疑。</li></ul><h3 id="2-算法复杂度相对较高"><a href="#2-算法复杂度相对较高" class="headerlink" title="2.算法复杂度相对较高"></a>2.<strong>算法复杂度相对较高</strong></h3><ul><li>与一些更简洁的算法相比，SM3 的轮函数和消息扩展步骤设计得相对复杂。这虽然增强了安全性，但也增加了实现和理解算法的难度，对于初学者或需要自行实现的开发者来说门槛稍高。</li></ul><h3 id="3-潜在的供应链依赖"><a href="#3-潜在的供应链依赖" class="headerlink" title="3.潜在的供应链依赖"></a>3.<strong>潜在的供应链依赖</strong></h3><ul><li>虽然 SM3 是为了“自主可控”，但对于中国以外的国家和公司来说，使用 SM3 意味着需要依赖中国的密码标准和相关技术生态，这可能会引发他们对于供应链和技术依赖的担忧。</li></ul><h3 id="4-历史与审查因素"><a href="#4-历史与审查因素" class="headerlink" title="4.历史与审查因素"></a>4.<strong>历史与审查因素</strong></h3><ul><li>算法的设计过程由国家密码管理局主导，其内部设计决策和选择标准并未像 NIST 组织设计 SHA-3 (Keccak) 那样完全公开并举办全球竞赛。这种相对不透明的诞生过程，是部分人对其持保留态度的历史原因。</li></ul><h1 id="五、SM3算法的应用场景"><a href="#五、SM3算法的应用场景" class="headerlink" title="五、SM3算法的应用场景"></a>五、SM3算法的应用场景</h1><h3 id="1-金融支付"><a href="#1-金融支付" class="headerlink" title="1.金融支付"></a>1.<strong>金融支付</strong></h3><p>在电子支付和网上银行系统中，SM3算法用于保障交易信息的完整性。当用户进行转账交易时，系统会使用SM3对交易报文（如金额、收款方、时间戳等关键数据）生成唯一的数字指纹（哈希值），并与SM2数字签名结合使用。任何对交易数据的细微篡改都会导致哈希值完全不同，从而使签名验证失败，银行因此能够及时发现并拒绝非法交易，有效防止数据在传输过程中被恶意篡改。</p><h3 id="2-电子政务"><a href="#2-电子政务" class="headerlink" title="2.电子政务"></a>2.<strong>电子政务</strong></h3><p>在电子证照和公文流转领域，SM3算法是验证文件真实性与完整性的核心。例如，在签发电子营业执照时，发证机关会使用SM3算法对证照信息生成摘要，并通过数字签名技术将其固定。查验方只需重新计算证照的SM3值并与官方签名进行比对，即可快速、准确地验证证照是否被伪造或篡改，确保了电子公文和证照的法律效力与可信度。</p><h3 id="3-物联网安全"><a href="#3-物联网安全" class="headerlink" title="3.物联网安全"></a>3.<strong>物联网安全</strong></h3><p>对于海量的物联网设备，如智能电表，SM3算法用于实现安全的数据采集。电表在上传用电量数据时，会使用预共享的密钥与SM3算法生成消息认证码（MAC）并附加在报文中。数据中心接收到数据后，执行相同的计算来验证MAC的正确性。这种方式能有效识别并拒绝攻击者伪造或篡改的虚假数据，保障了计量数据的真实性和计费的准确性。</p><h3 id="4-区块链与版权保护"><a href="#4-区块链与版权保护" class="headerlink" title="4.区块链与版权保护"></a>4.<strong>区块链与版权保护</strong></h3><p>在国产区块链和数字版权平台中，SM3算法构成了数据不可篡改特性的基础。每个区块的交易信息都会通过SM3计算生成唯一的哈希值，并链接到下一个区块。一旦某个区块内的交易被修改，其哈希值就会改变，从而导致整个后续链失效。同样，原创者可以将作品的SM3哈希值存入区块链，作为其在特定时间点存在的、未经篡改的唯一数字指纹，为后续的版权确认与维权提供铁证。</p><h3 id="5-软件与系统安全"><a href="#5-软件与系统安全" class="headerlink" title="5.软件与系统安全"></a>5.<strong>软件与系统安全</strong></h3><p>在软件分发和系统完整性保护方面，SM3算法发挥着关键作用。软件开发商在发布安装包或固件时，会同时公布其SM3哈希值。用户下载后，可自行计算文件的SM3值并与官方值进行比对，以此验证文件在下载过程中是否完好无损，未被植入木马或病毒。在企业内部，系统管理员也可以通过定期计算关键系统文件的SM3哈希值，来检测文件是否被非法修改，从而确保系统环境的可信。</p><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p>SM3算法作为我国商用密码体系的核心基石，是由国家密码管理局自主设计并发布的密码杂凑算法。该算法通过生成唯一的256位”数字指纹”，为各类数字应用提供关键的安全保障。在技术层面，SM3采用强化设计的Merkle-Damgård结构，具备与SHA-256相当的安全强度，能有效抵抗各类密码攻击，同时保持了优异的运算性能。其应用已深度渗透到金融交易、电子政务、物联网、区块链等关键领域，不仅确保数据传输的完整性和真实性，更为数字身份认证、电子签名等场景提供可靠支撑。随着数字中国建设的深入推进，SM3在保障关键信息基础设施安全、维护数字经济秩序等方面发挥着不可替代的作用，已成为构建自主可控网络安全体系的战略支撑技术</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
